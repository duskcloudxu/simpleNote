---
title: java笔记
date: 2019-01-03 10:35:44
tags
---

# Java题目复习笔记

## Java虚拟机

- Java文件经过javac编译变成字节码文件(后缀是.class)，字节码文件是统一的，经过不同平台上的JVM编译成CPU可以理解的机器码。

## Java文件规范

- Java的源文件格式必须是.java后缀
- 一个Java编译命令可能产生几个字节码文件
- 运行字节码文件需要调用java命令
- Java的入口main函数必须是public static void前缀且接收参数为string []
- 一个Java源文件可以有多个main但只能有一个符合入口名函数标准的main.
- Java是半编译半解释型语言：扯tm的蛋。
- java.lang是自动导入的
- 方法签名：主键为函数名+参数列表，其参数列表顺序敏感。
- Java内所有变量都需要初始化。
- 静态方法：静态方法可以通过类名+方法名访问，也可以通过对象+方法名访问，即使用静态方法不需要存在对象。因此，静态方法也不允许访问非静态方法，因为此时对象不一定存在。
- private 不能修饰类
- 数组变量是对数组的引用，数组元素是对元素对象的引用
- 因为存在只接受对象的容器，所以所有原始数据类型都有对应的对象，自动装箱是将原始数据类型转换为对应封装对象，自动拆箱就反过来。


## Java内存管理机制
- 堆内存(heap),栈内存(stack)
    - 这个东西和数据结构里的heap没有半毛钱关系，在java中，heap中存储对象，stack存储局部变量和函数调用。两者的区别更多的体现在线程和内存分配的关系上：每一个线程都有一个栈，而堆只有一个。
- 当使用String var="xxx"这样的格式申明一个变量的时候，在堆中生成一个匿名对象，而var被存在stack中，其指向堆中的匿名对象。值得一提的是，当"xxx"再次被用于命名一个新的变量的时候，例如，var2,那么var2和var1连接的都是同一个匿名对象。

## Java继承
- 在子类调用构建函数的时候，如果没有显示申明调用哪个super函数，那么就默认调用无参构建函数。且super函数永远应该在第一行，所以可以说是从构造函数的执行顺序是从最远祖先一路下行到子类的
- super不能嵌套使用，即子类不能使用爷类（……= =）的成员方法和变量
- 子类是向上兼容的，即可以用父类声明一个引用，然后实例化一个子类对象并赋给父类引用。

## 抽象类与接口
抽象类用abstract关键词修饰，其不可被实例化，但是可以被继承。
因为抽象类是抽象的，所以允许存在抽象方法，其也用abstract关键词来修饰，抽象方法没有方法体，所有继承了存在抽象方法的抽象类的子类，除非其是抽象类，不然必须要实现所有抽象方法。
- 接口所有成员变量都为public static final，这样符合接口实际的用途。其成员方法都是public(不用说了) abstract（也不用说了）

## 文件读写
- File类包含一个检查文件是否存在的方法




